{"version":3,"sources":["webpack://backend/webpack/bootstrap","webpack://backend/./backend/src/common/dingtalkHelper.js","webpack://backend/external \"require3\"","webpack://backend/./backend/src/common/authProviderScenes.js","webpack://backend/./backend/src/common/dingtalkUtils.js","webpack://backend/./backend/src/main.js","webpack://backend/./backend/src/config/config.js","webpack://backend/./backend/src/config/locales.js","webpack://backend/./backend/src/config/locale/zh-cn.js","webpack://backend/./backend/src/config/errors.js","webpack://backend/./backend/src/config/middlewares.js","webpack://backend/./backend/src/config/middleware/dingtalk.js","webpack://backend/./backend/src/config/middleware/inDingtalk.js","webpack://backend/./backend/src/routes.js","webpack://backend/./backend/src/controller/version.js","webpack://backend/./backend/src/controller/callback.js","webpack://backend/external \"crypto\"","webpack://backend/./backend/src/controller/contacts.js","webpack://backend/./backend/src/controller/event.js","webpack://backend/./backend/src/controller/jssdk.js","webpack://backend/./backend/src/controller/authMini.js","webpack://backend/./backend/src/services.js","webpack://backend/./backend/src/service/version.js","webpack://backend/./backend/src/service/callback.js","webpack://backend/./backend/src/service/contacts.js","webpack://backend/./backend/src/service/event.js","webpack://backend/./backend/src/service/jssdk.js","webpack://backend/./backend/src/service/authMini.js","webpack://backend/./backend/src/models.js","webpack://backend/./backend/src/model/department.js","webpack://backend/./backend/src/model/member.js","webpack://backend/./backend/src/meta.js","webpack://backend/./backend/src/passport/auth.js","webpack://backend/./backend/src/passport/strategy-dingtalk.js","webpack://backend/./backend/src/passport/oauth.js","webpack://backend/./backend/src/config/socketio/messageProgress.js","webpack://backend/./backend/src/config/socketio/channelApp.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA;AACA;AACA,2BAA2B,mBAAO,CAAC,CAAyB;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,WAAW;AACX;AACA,oCAAoC;AACpC;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,oCAAoC;AACpC;AACA;AACA,2DAA2D,mBAAmB;AAC9E;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA,0BAA0B,uEAAuE;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA,sDAAsD,2CAA2C;AACjG;AACA;AACA;AACA,iDAAiD,8BAA8B;AAC/E;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,gCAAgC,WAAW;AAC3C;AACA;AACA,oCAAoC,WAAW;AAC/C;;AAEA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wCAAwC;AACxE;AACA;AACA;AACA;;AAEA,+BAA+B,4CAA4C;AAC3E;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,SAAS,GAAG,cAAc;AACvE;AACA,SAAS;AACT;AACA,6CAA6C,SAAS,GAAG,cAAc;AACvE;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS,GAAG,QAAQ,GAAG,KAAK;AAC5E;AACA,SAAS;AACT;AACA,gDAAgD,SAAS,GAAG,QAAQ,GAAG,KAAK;AAC5E;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;;;;;;AC1RA,qC;;;;;;ACAA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW,KAAK,gCAAgC;AAClE;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACpCA,eAAe,mBAAO,CAAC,EAAQ;;AAE/B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iBAAiB,oCAAoC;AACrD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACzBA,eAAe,mBAAO,CAAC,CAAoB;AAC3C,gBAAgB,mBAAO,CAAC,CAAqB;AAC7C,eAAe,mBAAO,CAAC,CAAoB;AAC3C,oBAAoB,mBAAO,CAAC,CAAyB;;AAErD;;AAEA;AACA,iBAAiB,mBAAO,CAAC,EAAa;AACtC;AACA,mBAAmB,mBAAO,CAAC,EAAe;AAC1C;AACA,iBAAiB,mBAAO,CAAC,EAAa;AACtC;AACA,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;;;;;;AChLA;AACA,WAAW,mBAAO,CAAC,CAAmB;AACtC;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACRA,iBAAiB,mBAAO,CAAC,EAA0B;AACnD,mBAAmB,mBAAO,CAAC,EAA4B;;AAEvD;AACA;AACA;AACA;;;;;;;ACNA,yBAAyB,mBAAO,CAAC,CAAgC;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;;;;;;;;ACrBA,yBAAyB,mBAAO,CAAC,CAAgC;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA,gBAAgB,mBAAO,CAAC,EAAyB;AACjD,iBAAiB,mBAAO,CAAC,EAA0B;AACnD,iBAAiB,mBAAO,CAAC,EAA0B;;AAEnD,cAAc,mBAAO,CAAC,EAAuB;AAC7C,cAAc,mBAAO,CAAC,EAAuB;AAC7C,iBAAiB,mBAAO,CAAC,EAA0B;;AAEnD;AACA;AACA;AACA,KAAK,oFAAoF;AACzF,KAAK,kFAAkF;AACvF,KAAK,iFAAiF;AACtF;AACA,KAAK,+FAA+F,QAAQ,gBAAgB,EAAE,EAAE;AAChI,KAAK,sGAAsG,QAAQ,gBAAgB,EAAE,EAAE;AACvI;AACA,KAAK,qEAAqE,SAAS,qCAAqC,EAAE,EAAE;AAC5H;AACA,KAAK;AACL,aAAa,QAAQ,gBAAgB,EAAE;AACvC,KAAK;;AAEL;AACA,KAAK,mFAAmF;AACxF,KAAK,wFAAwF;AAC7F;AACA,KAAK,0FAA0F,QAAQ,gBAAgB,EAAE,EAAE;;AAE3H;AACA,KAAK,6FAA6F,QAAQ,gBAAgB,EAAE,EAAE;;AAE9H;AACA;AACA;;;;;;;ACnCA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACpBA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA,sBAAsB,mBAAO,CAAC,CAA4B;;AAE1D;AACA;;AAEA;AACA,qDAAqD,UAAU;AAC/D,sDAAsD,UAAU;AAChE,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC9CA,mC;;;;;;ACAA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,wBAAwB,aAAa;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC5CA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACbA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACnBA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;;;;;;ACbA,gBAAgB,mBAAO,CAAC,EAAsB;AAC9C,iBAAiB,mBAAO,CAAC,EAAuB;AAChD,iBAAiB,mBAAO,CAAC,EAAuB;AAChD,cAAc,mBAAO,CAAC,EAAoB;AAC1C,cAAc,mBAAO,CAAC,EAAoB;AAC1C,iBAAiB,mBAAO,CAAC,EAAuB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD;AACA,uDAAuD,gBAAgB;AACvE;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzFA,sBAAsB,mBAAO,CAAC,CAA4B;;AAE1D;AACA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,4BAA4B,KAAK,wBAAwB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACvFA,yBAAyB,mBAAO,CAAC,CAA6B;;AAE9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,2BAA2B;AAChD;AACA,0CAA0C,qBAAqB;AAC/D,OAAO;AACP,sCAAsC,qBAAqB;AAC3D;AACA;;AAEA,8BAA8B,UAAU;AACxC;AACA,kDAAkD,UAAU;AAC5D,OAAO;AACP,8CAA8C,UAAU;AACxD;AACA;;AAEA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA,OAAO;AACP;AACA,6CAA6C,oCAAoC;AACjF,OAAO;AACP,6CAA6C,oCAAoC;AACjF;AACA;AACA;AACA;;AAEA,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB;AAC3D,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB,mCAAmC,gBAAgB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qCAAqC;AAC9E,OAAO;AACP,yCAAyC,4BAA4B;AACrE;AACA;;AAEA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gCAAgC,8BAA8B,OAAO;AAC1G;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qCAAqC,gCAAgC,kCAAkC,IAAI,iCAAiC,OAAO;AACnJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4BAA4B;AACvE;AACA;AACA;AACA;AACA;AACA,iDAAiD,oCAAoC;AACrF;AACA,yCAAyC,8BAA8B,+BAA+B,GAAG;AACzG;AACA;AACA;AACA;AACA;AACA,qCAAqC,gCAAgC,gCAAgC,OAAO;AAC5G,OAAO;AACP;AACA,qCAAqC,uCAAuC;AAC5E;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,qBAAqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gCAAgC,8BAA8B,OAAO;AAC1G;AACA,oEAAoE,wBAAwB;AAC5F;AACA;AACA;AACA;AACA,qCAAqC,gCAAgC,8BAA8B,IAAI,6BAA6B,OAAO;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA,6CAA6C,4BAA4B;AACzE;AACA,yCAAyC,8BAA8B,iBAAiB,GAAG;AAC3F;AACA;AACA;AACA,qCAAqC,gCAAgC,gCAAgC,OAAO;AAC5G,OAAO;AACP;AACA,qCAAqC,uCAAuC;AAC5E;AACA;AACA;AACA;;AAEA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA,kBAAkB,eAAe,YAAY,mBAAmB;AAChE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA,qCAAqC,8BAA8B,0BAA0B,GAAG;AAChG;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA,qCAAqC,8BAA8B,YAAY,GAAG;AAClF;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA,oCAAoC,8BAA8B;AAClE;AACA;AACA,+DAA+D,wCAAwC;AACvG;AACA;AACA;AACA;AACA;AACA,uCAAuC,8CAA8C;AACrF;AACA,8CAA8C,yBAAyB;AACvE;;AAEA,gCAAgC,sBAAsB;AACtD;AACA;AACA,uDAAuD,4BAA4B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA,0CAA0C,qBAAqB;AAC/D;;AAEA,oCAAoC,8BAA8B;AAClE;AACA;AACA,+DAA+D,wCAAwC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sCAAsC;AACvD,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,6CAA6C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAA0C;AAC1E;AACA,mCAAmC,6CAA6C;AAChF;;AAEA,gCAAgC,sBAAsB;AACtD;AACA;AACA,uDAAuD,4BAA4B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0CAA0C,mCAAmC;AAC7E;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,aAAa;AACjD;AACA,0DAA0D,8CAA8C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,eAAe,aAAa;AAC5B,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA,8CAA8C,iCAAiC;AAC/E;AACA;;AAEA,4BAA4B,wBAAwB;AACpD;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA,8DAA8D,8CAA8C;AAC5G;;AAEA;AACA;AACA,kCAAkC,sDAAsD;AACxF;AACA;;AAEA;AACA;AACA,0CAA0C,yBAAyB;AACnE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA,8DAA8D,eAAe;AAC7E;AACA,2CAA2C,wBAAwB;AACnE;;AAEA;AACA;AACA,0DAA0D,0DAA0D;AACpH,oDAAoD,oFAAoF;AACxI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;AClfA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;;AAEA;;AAEA;;AAEA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;;;;;;AC1BA;;AAEA;;AAEA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACjCA,yBAAyB,mBAAO,CAAC,CAA6B;;AAE9D;;AAEA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,yCAAyC,qBAAqB,MAAM,aAAa;AACjF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;ACzBA,mBAAmB,mBAAO,CAAC,EAAuB;AAClD,eAAe,mBAAO,CAAC,EAAmB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACTA;AACA;AACA;AACA,kBAAkB,yCAAyC,uBAAuB,EAAE;AACpF;AACA;AACA;AACA;;;;;;;ACPA;AACA;AACA;AACA,kBAAkB,qCAAqC,wBAAwB,EAAE;AACjF;AACA;AACA;AACA;;;;;;;ACPA,eAAe,mBAAO,CAAC,EAAoB;;AAE3C;AACA;AACA;AACA,kCAAkC,mBAAO,CAAC,EAAsC;AAChF,6BAA6B,mBAAO,CAAC,EAAiC;AACtE;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,kBAAkB;AAClB;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;;;;;;ACzDA,iBAAiB,mBAAO,CAAC,EAAwB;AACjD,yBAAyB,mBAAO,CAAC,CAA6B;AAC9D,2BAA2B,mBAAO,CAAC,CAAiC;;AAEpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,kBAAkB;AAClB,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB,sBAAsB,wBAAwB,EAAE;AACjE,eAAe;AACf,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,kBAAkB;AAClB,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe,sBAAsB,wBAAwB,EAAE;AAC/D,aAAa;AACb,WAAW;AACX;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACpJA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;AACA;AACA,cAAc,mBAAO,CAAC,EAAY;;AAElC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AC7GA,iBAAiB,mBAAO,CAAC,CAAU;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;;;;;;ACVA,yBAAyB,mBAAO,CAAC,CAAgC;;AAEjE;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA","file":"backend.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","const require3 = require('require3');\nconst bb = require3('bluebird');\nconst extend = require3('extend2');\nconst DingtalkAPI = require3('@zhennann/node-dingtalk');\nconst authProviderScenes = require('./authProviderScenes.js');\n\nmodule.exports = function(ctx) {\n  const moduleInfo = ctx.app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class WxworkHelper {\n\n    getSceneInfo(scene) {\n      return authProviderScenes.getScene(scene);\n    }\n\n    // ctx.meta.dingtalk.app.selfBuilt\n    // ctx.meta.dingtalk.admin\n    // ctx.meta.dingtalk.web.default\n    // ctx.meta.dingtalk.mini.default\n    createDingtalkApi() {\n      const self = this;\n      return new Proxy({}, {\n        get(obj, prop) {\n          if (obj[prop]) return obj[prop];\n          if (prop === 'app') {\n            // app\n            obj[prop] = new Proxy({}, {\n              get(obj, prop) {\n                if (!obj[prop]) {\n                  obj[prop] = self._createDingtalkApiApp({ appName: prop });\n                }\n                return obj[prop];\n              },\n            });\n          } else if (prop === 'admin') {\n            obj[prop] = self._createDingtalkApiAdmin();\n          } else if (prop === 'web') {\n            // web\n            obj[prop] = new Proxy({}, {\n              get(obj, prop) {\n                if (!obj[prop]) {\n                  obj[prop] = self._createDingtalkApiWeb({ webName: prop });\n                }\n                return obj[prop];\n              },\n            });\n          } else if (prop === 'mini') {\n            // mini\n            obj[prop] = new Proxy({}, {\n              get(obj, prop) {\n                if (!obj[prop]) {\n                  obj[prop] = self._createDingtalkApiMini({ sceneShort: prop });\n                }\n                return obj[prop];\n              },\n            });\n          } else if (prop === 'util') {\n            // util\n            obj[prop] = self._createDingtalkApiUtil();\n          }\n          return obj[prop];\n        },\n      });\n    }\n\n    // scene: dingtalk/dingtalkweb/dingtalkadmin/dingtalkmini\n    async verifyAuthUser({ scene, memberId, member, cbVerify, state = 'login', needLogin = true }) {\n      if (state === 'associate') {\n        // not allowed associate\n        return ctx.throw(403);\n      }\n      // userInfo(member)\n      if (!member) {\n        member = await this._getMemberByMemberId({ memberId });\n        if (!member) return ctx.throw(403);\n      }\n      // ensure auth user\n      const profileUser = await this._ensureAuthUser({ scene, memberId: member.memberId, member });\n      // verify\n      let verifyUser;\n      if (!cbVerify) {\n        verifyUser = await ctx.meta.user.verify({ state: 'login', profileUser });\n        if (needLogin) {\n          await ctx.login(verifyUser);\n        }\n      } else {\n        verifyUser = await bb.fromCallback(cb => {\n          cbVerify(profileUser, cb);\n        });\n      }\n      // ok\n      return verifyUser;\n    }\n\n    async _getMemberByMemberId({ memberId }) {\n      // model member\n      const modelMember = ctx.model.module(moduleInfo.relativeName).member;\n      return await modelMember.get({ memberId });\n    }\n\n    // profileId: dingtalk:memberId\n    async _ensureAuthUser({ scene, memberId, member }) {\n      // model auth\n      const modelAuth = ctx.model.module('a-base').auth;\n      //\n      const sceneInfo = this.getSceneInfo(scene);\n      const profileId = `dingtalk:${memberId}`;\n      const profileUser = {\n        module: moduleInfo.relativeName,\n        provider: sceneInfo.authProvider,\n        profileId,\n        profile: {\n          userName: member.name,\n          realName: member.name,\n          avatar: member.avatar,\n          email: member.email,\n          mobile: member.mobile,\n          emailConfirmed: true,\n          mobileVerified: true,\n          profile: member,\n        },\n      };\n      // provider\n      const providerItem = await ctx.meta.user.getAuthProvider({\n        module: moduleInfo.relativeName,\n        providerName: sceneInfo.authProvider,\n      });\n      // check auth\n      let authId;\n      let authUserId;\n      const authItems = await ctx.model.query(\n        'select * from aAuth a where a.deleted=0 and a.iid=? and a.providerId=? and a.profileId=?',\n        [ ctx.instance.id, providerItem.id, profileId ]\n      );\n      const authItem = authItems[0];\n      if (!authItem) {\n        // always set avatar empty\n        const _profile = extend(true, {}, profileUser.profile);\n        delete _profile.avatar;\n        // insert auth\n        const res = await modelAuth.insert({\n          providerId: providerItem.id,\n          profileId,\n          profile: JSON.stringify(_profile),\n        });\n        authId = res.insertId;\n      } else {\n        // hold old avatar empty\n        const _profile = extend(true, {}, profileUser.profile);\n        const _profileOld = JSON.parse(authItem.profile);\n        _profile.avatar = _profileOld.avatar;\n        // always update\n        await modelAuth.update({\n          id: authItem.id,\n          profile: JSON.stringify(_profile),\n        });\n        authId = authItem.id;\n        authUserId = authItem.userId;\n      }\n      // check if has userId for memberId\n      const _authOthers = await ctx.model.query(\n        'select * from aAuth a where a.deleted=0 and a.iid=? and a.profileId=? and a.id<>?',\n        [ ctx.instance.id, profileId, authId ]\n      );\n      const _authOther = _authOthers[0];\n      if (_authOther && _authOther.userId !== authUserId) {\n        // update userId for this auth\n        await modelAuth.update({ id: authId, userId: _authOther.userId });\n      }\n      // ready\n      return profileUser;\n    }\n\n    _createDingtalkApiGeneral({ category, appName, appkey, appsecret, sso }) {\n      // api\n      const api = new DingtalkAPI(\n        {\n          appkey, appsecret, sso,\n        },\n        async function() {\n          const cacheKey = `dingtalk-token:${category}:${appName || ''}`;\n          return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n        },\n        async function(token) {\n          const cacheKey = `dingtalk-token:${category}:${appName || ''}`;\n          if (token) {\n            await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n          } else {\n            await ctx.cache.db.module(moduleInfo.relativeName).remove(cacheKey);\n          }\n        }\n      );\n      // registerTicketHandle\n      api.client.registerTicketHandle(\n        async function(type) {\n          const cacheKey = `dingtalk-jsticket:${category}:${appName}:${type}`;\n          return await ctx.cache.db.module(moduleInfo.relativeName).get(cacheKey);\n        },\n        async function(type, token) {\n          const cacheKey = `dingtalk-jsticket:${category}:${appName}:${type}`;\n          if (token) {\n            await ctx.cache.db.module(moduleInfo.relativeName).set(cacheKey, token, token.expireTime - Date.now());\n          } else {\n            await ctx.cache.db.module(moduleInfo.relativeName).remove(cacheKey);\n          }\n        }\n      );\n      // ready\n      return api;\n    }\n\n    _createDingtalkApiApp({ appName }) {\n      // config\n      const config = ctx.config.module(moduleInfo.relativeName).account.dingtalk;\n      const configApp = config.apps[appName];\n      return this._createDingtalkApiGeneral({\n        category: 'app',\n        appName,\n        appkey: configApp.appkey,\n        appsecret: configApp.appsecret,\n      });\n    }\n\n    _createDingtalkApiAdmin() {\n      // config\n      const config = ctx.config.module(moduleInfo.relativeName).account.dingtalk;\n      return this._createDingtalkApiGeneral({\n        category: 'admin',\n        appName: '',\n        appkey: config.corpid,\n        appsecret: config.ssosecret,\n        sso: true,\n      });\n    }\n\n    _createDingtalkApiWeb({ webName }) {\n      // config\n      const config = ctx.config.module(moduleInfo.relativeName).account.dingtalk;\n      const configWeb = config.webs[webName];\n      return this._createDingtalkApiGeneral({\n        category: 'web',\n        appName: webName,\n        appkey: configWeb.appid,\n        appsecret: configWeb.appsecret,\n      });\n    }\n\n    _createDingtalkApiMini({ sceneShort }) {\n      // config\n      const config = ctx.config.module(moduleInfo.relativeName).account.dingtalk;\n      const configMini = config.minis[sceneShort];\n      return this._createDingtalkApiGeneral({\n        category: 'mini',\n        appName: sceneShort,\n        appkey: configMini.appkey,\n        appsecret: configMini.appsecret,\n      });\n    }\n\n    _createDingtalkApiUtil() {\n      return {\n        // scene: empty/dingtalk/dingtalkweb/dingtalkadmin/dingtalkmini/dingtalkminidefault/xxx,xxx,xxx\n        in(scene) {\n          // scene\n          if (!scene) scene = 'dingtalk';\n          if (typeof scene === 'string') scene = scene.split(',');\n          // provider\n          const provider = ctx.user && ctx.user.provider;\n          if (!provider || provider.module !== moduleInfo.relativeName) return false;\n          // find any match\n          for (const item of scene) {\n            const ok = (provider.providerName === item) || (item === 'dingtalkmini' && provider.providerName.indexOf(item) > -1);\n            if (ok) return true;\n          }\n          // not found\n          return false;\n        },\n      };\n    }\n\n  }\n\n  return WxworkHelper;\n};\n","module.exports = require(\"require3\");","const _scenes = {\n  dingtalk: {\n    scene: 'dingtalk', authProvider: 'dingtalk', title: 'DingTalk', client: 'dingtalk',\n  },\n  dingtalkweb: {\n    scene: 'dingtalkweb', authProvider: 'dingtalkweb', title: 'DingTalk Web', client: 'dingtalkweb',\n  },\n  dingtalkadmin: {\n    scene: 'dingtalkadmin', authProvider: 'dingtalkadmin', title: 'DingTalk Admin', client: 'dingtalkadmin',\n  },\n  dingtalkmini: {\n    scene: 'dingtalkmini', authProvider: 'dingtalkmini', title: 'DingTalk Miniprogram',\n  },\n};\n\nfunction _upperCaseFirstChar(str) {\n  if (!str) return '';\n  return str.substring(0, 1).toUpperCase() + str.substring(1);\n}\n\nmodule.exports = {\n  scenes: _scenes,\n  getScene(scene) {\n    if (scene.indexOf('dingtalkmini') > -1) {\n      const sceneShort = scene.substr('dingtalkmini'.length);\n      // dingtalkmini\n      const base = _scenes.dingtalkmini;\n      return {\n        scene,\n        authProvider: scene,\n        title: `${base.title} - ${_upperCaseFirstChar(sceneShort)}`,\n      };\n    }\n    // else\n    return _scenes[scene];\n  },\n};\n","const crypto = require('crypto');\n\nmodule.exports = {\n  createNonceStr() {\n    return Math.random().toString(36).substr(2, 15);\n  },\n  createTimestamp() {\n    return '' + Date.now();\n  },\n  calcSignature({ options, join = '', hash = 'sha1' }) {\n    const hashsum = crypto.createHash(hash);\n    hashsum.update(options.join(join));\n    return hashsum.digest('hex');\n  },\n  symmetricDifference(setA, setB) {\n    const _difference = new Set(setA);\n    for (const elem of setB) {\n      if (_difference.has(elem)) {\n        _difference.delete(elem);\n      } else {\n        _difference.add(elem);\n      }\n    }\n    return _difference;\n  },\n};\n","const config = require('./config/config.js');\nconst locales = require('./config/locales.js');\nconst errors = require('./config/errors.js');\nconst middlewares = require('./config/middlewares.js');\n\nmodule.exports = app => {\n\n  // routes\n  const routes = require('./routes.js')(app);\n  // services\n  const services = require('./services.js')(app);\n  // models\n  const models = require('./models.js')(app);\n  // meta\n  const meta = require('./meta.js')(app);\n\n  return {\n    routes,\n    services,\n    models,\n    config,\n    locales,\n    errors,\n    middlewares,\n    meta,\n  };\n\n};\n","\nconst jsApiList = [\n  'device.base.getUUID',\n  'device.base.getInterface',\n  'device.nfc.nfcWrite',\n  'runtime.permission.requestOperateAuthCode',\n  'biz.util.scanCard',\n  'device.geolocation.get',\n  'device.geolocation.start',\n  'device.geolocation.stop',\n  'biz.map.locate',\n  'biz.map.search',\n  'biz.map.view',\n  'biz.clipboardData.setData',\n  'biz.util.ut',\n  'biz.util.open',\n  'biz.telephone.call',\n  'biz.telephone.showCallMenu',\n  'biz.telephone.checkBizCall',\n  'biz.telephone.quickCallList',\n  'biz.ding.create',\n  'biz.ding.post',\n  'biz.contact.choose',\n  'biz.contact.chooseMobileContacts',\n  'biz.contact.complexPicker',\n  'biz.contact.departmentsPicker',\n  'biz.contact.createGroup',\n  'biz.contact.setRule',\n  'biz.contact.externalComplexPicker',\n  'biz.contact.externalEditForm',\n  'biz.customContact.choose',\n  'biz.customContact.multipleChoose',\n  'biz.chat.pickConversation',\n  'biz.chat.chooseConversationByCorpId',\n  'biz.chat.openSingleChat',\n  'biz.chat.toConversation',\n  'biz.cspace.saveFile',\n  'biz.cspace.preview',\n  'biz.cspace.chooseSpaceDir',\n  'biz.util.uploadAttachment',\n  'device.audio.startRecord',\n  'device.audio.stopRecord',\n  'device.audio.onRecordEnd',\n  'device.audio.download',\n  'device.audio.play',\n  'device.audio.pause',\n  'device.audio.resume',\n  'device.audio.stop',\n  'device.audio.onPlayEnd',\n  'device.audio.translateVoice',\n  'biz.conference.videoConfCall',\n  'biz.alipay.pay',\n  'biz.util.encrypt',\n  'biz.util.decrypt',\n];\n\nconst businessCallbackList = [\n  // 通讯录\n  'user_add_org',\n  'user_modify_org',\n  'user_leave_org',\n  'user_active_org',\n  'org_admin_add',\n  'org_admin_remove',\n  'org_dept_create',\n  'org_dept_modify',\n  'org_dept_remove',\n  'org_remove',\n  'org_change',\n  'label_user_change',\n  'label_conf_add',\n  'label_conf_del',\n  'label_conf_modify',\n  // 审批\n  'bpms_task_change',\n  'bpms_instance_change',\n  // 群会话\n  'chat_add_member',\n  'chat_remove_member',\n  'chat_quit',\n  'chat_update_owner',\n  'chat_update_title',\n  'chat_disband',\n  // 签到\n  'check_in',\n  // 考勤\n  'attendance_check_record',\n  'attendance_schedule_change',\n  'attendance_overtime_duration',\n  // 会议室\n  'meetingroom_book',\n  'meetingroom_room_info',\n];\n\nmodule.exports = appInfo => {\n  const config = {};\n\n  // queues\n  config.queues = {\n    contacts: {\n      path: 'contacts/queue',\n    },\n  };\n\n  // startups\n  config.startups = {\n    registerBusinessCallbackList: {\n      instance: true,\n      path: 'callback/registerList',\n      debounce: true,\n      after: true,\n    },\n  };\n\n  // middlewares\n  config.middlewares = {\n    dingtalk: {\n      global: false,\n      dependencies: 'instance',\n    },\n    inDingtalk: {\n      global: false,\n      dependencies: 'instance',\n    },\n  };\n\n  // sync\n  config.sync = {\n    department: {\n      roleContainer: 'internal',\n      roleTop: 'dingtalk',\n    },\n  };\n\n  // account\n  config.account = {};\n\n  // account.dingtalk\n  config.account.dingtalk = {\n    corpid: '',\n    ssosecret: '',\n    // apps\n    apps: {\n      selfBuilt: {\n        agentid: '',\n        appkey: '',\n        appsecret: '',\n        jssdk: {\n          jsApiList,\n        },\n        businessCallback: {\n          host: '',\n          token: appInfo.name,\n          encodingAESKey: '',\n          list: businessCallbackList,\n        },\n      },\n    },\n    // webs\n    webs: {\n      default: {\n        appid: '',\n        appsecret: '',\n      },\n    },\n    // minis\n    minis: {\n      default: {\n        agentid: '',\n        appkey: '',\n        appsecret: '',\n      },\n    },\n  };\n\n  return config;\n};\n","module.exports = {\n  'zh-cn': require('./locale/zh-cn.js'),\n};\n","module.exports = {\n  DingTalk: '钉钉',\n  'DingTalk Miniprogram': '钉钉小程序',\n  'DingTalk Miniprogram - Default': '钉钉小程序 - 默认',\n  'DingTalk Web': '钉钉Web',\n  'Not In DingTalk': '不在钉钉内部',\n  'Not In DingTalk Miniprogram': '不在钉钉小程序内部',\n  'Contacts Management': '通讯录管理',\n  'Sync Started': '同步已启动',\n  'Sync Completed': '同步已完成',\n  'Department Count': '部门数量',\n  'Member Count': '成员数量',\n  'Sync Departments First': '请先同步部门',\n};\n","// error code should start from 1001\nmodule.exports = {\n  1001: 'Not In DingTalk',\n  1002: 'Not In DingTalk Miniprogram',\n  1003: 'Role not Found for department: %d',\n  1004: 'Department not Found: %d',\n  1005: 'Member not Found: %d',\n  1006: 'Sync Departments First',\n};\n","const dingtalk = require('./middleware/dingtalk.js');\nconst inDingtalk = require('./middleware/inDingtalk.js');\n\nmodule.exports = {\n  dingtalk,\n  inDingtalk,\n};\n","const DingtalkHelperFn = require('../../common/dingtalkHelper.js');\nconst DINGTALK = Symbol('CTX#DINGTALK');\n\nmodule.exports = (options, app) => {\n  // const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  return async function dingtalk(ctx, next) {\n    ctx.meta = ctx.meta || {};\n    Object.defineProperty(ctx.meta, 'dingtalk', {\n      get() {\n        if (ctx.meta[DINGTALK] === undefined) {\n          const dingtalkHelper = new (DingtalkHelperFn(ctx))();\n          ctx.meta[DINGTALK] = dingtalkHelper.createDingtalkApi();\n        }\n        return ctx.meta[DINGTALK];\n      },\n    });\n\n    // next\n    await next();\n  };\n\n};\n\n","const DingtalkHelperFn = require('../../common/dingtalkHelper.js');\n\nmodule.exports = (options, app) => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  return async function inWxwork(ctx, next) {\n    const dingtalkHelper = new (DingtalkHelperFn(ctx))();\n    const api = dingtalkHelper.createDingtalkApi();\n    if (!api.util.in(options.scene)) return ctx.throw.module(moduleInfo.relativeName, 1001);\n    // next\n    await next();\n  };\n};\n","const version = require('./controller/version.js');\nconst callback = require('./controller/callback.js');\nconst contacts = require('./controller/contacts.js');\n\nconst event = require('./controller/event.js');\nconst jssdk = require('./controller/jssdk.js');\nconst authMini = require('./controller/authMini.js');\n\nmodule.exports = app => {\n  const routes = [\n    // version\n    { method: 'post', path: 'version/update', controller: version, middlewares: 'inner' },\n    { method: 'post', path: 'version/init', controller: version, middlewares: 'inner' },\n    { method: 'post', path: 'version/test', controller: version, middlewares: 'test' },\n    // message\n    { method: 'post', path: 'callback/index', controller: callback, middlewares: 'dingtalk', meta: { auth: { enable: false } } },\n    { method: 'post', path: 'callback/registerList', controller: callback, middlewares: 'dingtalk', meta: { auth: { enable: false } } },\n    // contacts\n    { method: 'post', path: 'contacts/sync', controller: contacts, meta: { right: { type: 'function', name: 'contacts' } } },\n    // queue\n    { method: 'post', path: 'contacts/queue', controller: contacts, middlewares: 'inner,transaction,dingtalk',\n      meta: { auth: { enable: false } },\n    },\n\n    // jsapi\n    { method: 'post', path: 'jssdk/jsconfig', controller: jssdk, middlewares: 'wxwork' },\n    { method: 'post', path: 'jssdk/jsconfigAgent', controller: jssdk, middlewares: 'wxwork' },\n    // event\n    { method: 'post', path: 'event/loginInfo', controller: event, middlewares: 'inner', meta: { auth: { enable: false } } },\n\n    // authMini\n    { method: 'post', path: 'authMini/login', controller: authMini, middlewares: 'wxwork', meta: { auth: { enable: false } } },\n\n  ];\n  return routes;\n};\n","module.exports = app => {\n  class VersionController extends app.Controller {\n\n    async update() {\n      await this.service.version.update(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n    async init() {\n      await this.service.version.init(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n    async test() {\n      await this.service.version.test(this.ctx.request.body);\n      this.ctx.success();\n    }\n\n  }\n  return VersionController;\n};\n","const require3 = require('require3');\nconst DingTalkEncryptor = require3('dingtalk-encrypt');\nconst dingtalkUtils = require('../common/dingtalkUtils.js');\n\nmodule.exports = app => {\n  class CallbackController extends app.Controller {\n\n    async index() {\n      await this._handleMessage('selfBuilt', async ({ message }) => {\n        return await this.ctx.service.callback.index({ message });\n      });\n    }\n\n    async registerList() {\n      await this.ctx.service.callback.registerList();\n      this.ctx.success();\n    }\n\n    async _handleMessage(appName, handler) {\n      // query\n      const query = this.ctx.query;\n      // config\n      const config = this.ctx.config.account.dingtalk;\n      const configApp = config.apps[appName];\n      // dingtalk crypto\n      const encryptor = new DingTalkEncryptor(configApp.businessCallback.token, configApp.businessCallback.encodingAESKey, config.corpid);\n      // parse\n      const message = await this._parseMessagePost({ query, encryptor });\n      // handle\n      await handler({ message });\n      // ok\n      const res = encryptor.getEncryptedMap('success', dingtalkUtils.createTimestamp(), dingtalkUtils.createNonceStr());\n      this.ctx.status = 200;\n      this.ctx.type = 'application/json';\n      this.ctx.body = res;\n    }\n\n    async _parseMessagePost({ query, encryptor }) {\n      const plainText = encryptor.getDecryptMsg(\n        query.signature, query.timestamp, query.nonce,\n        this.ctx.request.body.encrypt);\n      return JSON.parse(plainText);\n    }\n\n  }\n  return CallbackController;\n};\n\n","module.exports = require(\"crypto\");","const require3 = require('require3');\nconst uuid = require3('uuid');\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class ContactsController extends app.Controller {\n\n    async sync() {\n      // progress\n      const progressId = uuid.v4().replace(/-/g, '');\n      // queue\n      this.ctx.app.meta.queue.push({\n        locale: this.ctx.locale,\n        subdomain: this.ctx.subdomain,\n        module: moduleInfo.relativeName,\n        queueName: 'contacts',\n        data: {\n          queueAction: 'sync',\n          type: this.ctx.request.body.type,\n          progressId,\n          userOp: this.ctx.user.op,\n        },\n      });\n      this.ctx.success({ progressId });\n    }\n\n    async queue() {\n      const queueAction = this.ctx.request.body.queueAction;\n      if (queueAction === 'sync') {\n        await this.service.contacts.queueSync({\n          type: this.ctx.request.body.type,\n          progressId: this.ctx.request.body.progressId,\n          userOp: this.ctx.request.body.userOp,\n        });\n      } else if (queueAction === 'changeContact') {\n        await this.service.contacts.queueChangeContact({\n          message: this.ctx.request.body.message,\n        });\n      }\n      this.ctx.success();\n    }\n\n  }\n  return ContactsController;\n};\n","module.exports = app => {\n  class EventController extends app.Controller {\n\n    async loginInfo() {\n      const res = await this.service.event.loginInfo({\n        event: this.ctx.request.body.event,\n        data: this.ctx.request.body.data,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return EventController;\n};\n","module.exports = app => {\n  class JSSDKController extends app.Controller {\n\n    async jsconfig() {\n      const res = await this.service.jssdk.jsconfig({\n        url: this.ctx.request.body.url,\n      });\n      this.ctx.success(res);\n    }\n\n    async jsconfigAgent() {\n      const res = await this.service.jssdk.jsconfigAgent({\n        url: this.ctx.request.body.url,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return JSSDKController;\n};\n","module.exports = app => {\n  class AuthMiniController extends app.Controller {\n\n    async login() {\n      const res = await this.service.authMini.login({\n        scene: this.ctx.request.body.scene,\n        code: this.ctx.request.body.code,\n      });\n      this.ctx.success(res);\n    }\n\n  }\n  return AuthMiniController;\n};\n","const version = require('./service/version.js');\nconst callback = require('./service/callback.js');\nconst contacts = require('./service/contacts.js');\nconst event = require('./service/event.js');\nconst jssdk = require('./service/jssdk.js');\nconst authMini = require('./service/authMini.js');\n\nmodule.exports = app => {\n  const services = {\n    version,\n    callback,\n    contacts,\n    event,\n    jssdk,\n    authMini,\n  };\n  return services;\n};\n","module.exports = app => {\n\n  class Version extends app.Service {\n\n    async update(options) {\n      if (options.version === 1) {\n\n        let sql;\n\n        // create table: aDingtalkDepartment\n        sql = `\n          CREATE TABLE aDingtalkDepartment (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            roleId int(11) DEFAULT '0',\n            departmentId int(11) DEFAULT '0',\n            departmentParentId int(11) DEFAULT '0',\n            departmentName varchar(255) DEFAULT NULL,\n            departmentOrder int(11) DEFAULT '0',\n            createDeptGroup int(11) DEFAULT '0',\n            autoAddUser int(11) DEFAULT '0',\n            deptHiding int(11) DEFAULT '0',\n            deptPermits TEXT DEFAULT NULL,\n            userPermits TEXT DEFAULT NULL,\n            outerDept int(11) DEFAULT '0',\n            outerPermitDepts TEXT DEFAULT NULL,\n            outerPermitUsers TEXT DEFAULT NULL,\n            outerDeptOnlySelf int(11) DEFAULT '0',\n            sourceIdentifier varchar(255) DEFAULT NULL,\n            ext JSON DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n        // create table: aDingtalkMember\n        sql = `\n          CREATE TABLE aDingtalkMember (\n            id int(11) NOT NULL AUTO_INCREMENT,\n            createdAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,\n            updatedAt timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n            deleted int(11) DEFAULT '0',\n            iid int(11) DEFAULT '0',\n            userId int(11) DEFAULT '0',\n            memberId varchar(255) DEFAULT NULL,\n            name varchar(255) DEFAULT NULL,\n            active int(11) DEFAULT '0',\n            avatar varchar(255) DEFAULT NULL,\n            orderInDepts JSON DEFAULT NULL,\n            department varchar(255) DEFAULT NULL,\n            position varchar(255) DEFAULT NULL,\n            mobile varchar(255) DEFAULT NULL,\n            tel varchar(255) DEFAULT NULL,\n            workPlace varchar(255) DEFAULT NULL,\n            remark TEXT DEFAULT NULL,\n            email varchar(255) DEFAULT NULL,\n            orgEmail varchar(255) DEFAULT NULL,\n            jobnumber varchar(255) DEFAULT NULL,\n            isHide int(11) DEFAULT '0',\n            isSenior int(11) DEFAULT '0',\n            extattr JSON DEFAULT NULL,\n            hiredDate timestamp DEFAULT NULL,\n            PRIMARY KEY (id)\n          )\n        `;\n        await this.ctx.model.query(sql);\n\n      }\n    }\n\n    async init(options) {\n      if (options.version === 1) {\n        // roleFunctions\n        const roleFunctions = [\n          { roleName: 'system', name: 'contacts' },\n        ];\n        await this.ctx.meta.role.addRoleFunctionBatch({ roleFunctions });\n      }\n    }\n\n    async test() {\n    }\n\n  }\n\n  return Version;\n};\n","const dingtalkUtils = require('../common/dingtalkUtils.js');\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Callback extends app.Service {\n\n    async index({ message }) {\n      // event: check_url\n      if (message.EventType === 'check_url') {\n        // just return\n        return;\n      }\n      // raise event\n      await this.ctx.meta.event.invoke({\n        module: moduleInfo.relativeName,\n        name: 'dingtalkCallback',\n        data: { message },\n      });\n    }\n\n    async registerList() {\n      // config\n      const config = this.ctx.config.account.dingtalk.apps.selfBuilt.businessCallback;\n      const host = config.host;\n      const token = config.token;\n      const encodingAESKey = config.encodingAESKey;\n      const callbackList = config.list;\n      const callbackUrl = `${this.ctx.meta.base.protocol}://${this.ctx.meta.base.host}/api/a/dingtalk/callback/index`;\n      // check\n      if (this.ctx.meta.base.host !== host || !token || !encodingAESKey || !callbackList) return;\n      // check status\n      const res = await this._tryGetList();\n      if (!res) {\n        // register\n        await this.ctx.meta.dingtalk.app.selfBuilt.callback.register_call_back({\n          call_back_tag: callbackList,\n          token,\n          aes_key: encodingAESKey,\n          url: callbackUrl,\n        });\n      } else {\n        // update\n        const call_back_tag_setRemote = new Set(res.call_back_tag);\n        const call_back_tag_setConfig = new Set(callbackList);\n        const diff = dingtalkUtils.symmetricDifference(call_back_tag_setRemote, call_back_tag_setConfig);\n        if (diff.size === 0) {\n          // do nothing\n        } else {\n          // difference\n          await this.ctx.meta.dingtalk.app.selfBuilt.callback.update_call_back({\n            call_back_tag: callbackList,\n            token,\n            aes_key: encodingAESKey,\n            url: callbackUrl,\n          });\n        }\n      }\n    }\n\n    async _tryGetList() {\n      try {\n        return await this.ctx.meta.dingtalk.app.selfBuilt.callback.get_call_back();\n      } catch (err) {\n        if (err.code === 71007) return null;\n        throw err;\n      }\n    }\n\n    async contacts({ message }) {\n      // queue\n      this.ctx.app.meta.queue.push({\n        locale: this.ctx.locale,\n        subdomain: this.ctx.subdomain,\n        module: moduleInfo.relativeName,\n        queueName: 'contacts',\n        data: {\n          queueAction: 'changeContact',\n          message,\n        },\n      });\n      // ok\n      return null;\n    }\n\n  }\n\n  return Callback;\n};\n","const DingtalkHelperFn = require('../common/dingtalkHelper.js');\n\n// department\n\nconst __departmentFieldMap = [\n  [ 'departmentId', 'departmentParentId', 'departmentName', 'departmentOrder', 'createDeptGroup', 'autoAddUser', 'deptHiding', 'deptPermits', 'userPermits', 'outerDept', 'outerPermitDepts', 'outerPermitUsers', 'outerDeptOnlySelf', 'sourceIdentifier', 'ext' ],\n  [ 'id', 'parentid', 'name', 'order', 'createDeptGroup', 'autoAddUser', 'deptHiding', 'deptPermits', 'userPermits', 'outerDept', 'outerPermitDepts', 'outerPermitUsers', 'outerDeptOnlySelf', 'sourceIdentifier', 'ext' ],\n  [ 'number', 'number', 'string', 'number', 'bool', 'bool', 'bool', 'string', 'string', 'bool', 'string', 'string', 'bool', 'string', 'string' ],\n];\n\nconst __departmentFieldMap_XML = [\n  [ 'departmentId', 'departmentParentId', 'departmentName', 'departmentOrder' ],\n  [ 'Id', 'ParentId', 'Name', 'Order' ],\n  [ 'number', 'number', 'string', 'number' ],\n];\n\n// member\n\nconst __memberFieldMap = [\n  [ 'memberId', 'name', 'active', 'avatar', 'orderInDepts', 'department', 'position', 'mobile', 'tel', 'workPlace', 'remark', 'email', 'orgEmail', 'jobnumber', 'isHide', 'isSenior', 'extattr', 'hiredDate' ],\n  [ 'userid', 'name', 'active', 'avatar', 'orderInDepts', 'department', 'position', 'mobile', 'tel', 'workPlace', 'remark', 'email', 'orgEmail', 'jobnumber', 'isHide', 'isSenior', 'extattr', 'hiredDate' ],\n  [ 'string', 'string', 'bool', 'string', 'string', 'array', 'string', 'string', 'string', 'string', 'string', 'string', 'string', 'string', 'bool', 'bool', 'json', 'timestamp' ],\n];\n\nconst __memberFieldMap_XML = [\n  [ 'memberIdNew', 'memberId', 'name', 'alias', 'mobile', 'department', 'position', 'gender', 'email', 'telephone', 'is_leader_in_dept', 'avatar', 'status', 'extattr', 'address' ],\n  [ 'NewUserID', 'UserID', 'Name', 'Alias', 'Mobile', 'Department', 'Position', 'Gender', 'Email', 'Telephone', 'IsLeaderInDept', 'Avatar', 'Status', 'ExtAttr', 'Address' ],\n  [ 'string', 'string', 'string', 'string', 'string', 'string', 'string', 'number', 'string', 'string', 'string', 'string', 'number', 'json', 'string' ],\n];\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  class Contacts extends app.Service {\n\n    async queueSync({ type, progressId, userOp }) {\n      if (type === 'departments') {\n        await this._queueSyncDepartments({ progressId, userOp });\n      } else if (type === 'members') {\n        await this._queueSyncMembers({ progressId, userOp });\n      }\n    }\n\n    async queueChangeContact({ message }) {\n      if (message.ChangeType.indexOf('_party') > -1) {\n        await this._queueChangeContactDepartment({ message });\n      } else if (message.ChangeType.indexOf('_user') > -1) {\n        await this._queueChangeContactMember({ message });\n      }\n    }\n\n    async _queueChangeContactDepartment({ message }) {\n      // department\n      const department = {};\n      this._adjustFields(department, message, __departmentFieldMap_XML);\n      // do\n      if (message.ChangeType === 'create_party') {\n        // create\n        await this._createRoleAndDepartment({ department });\n        // build roles\n        await this.ctx.meta.role.build();\n      } else if (message.ChangeType === 'update_party') {\n        // update\n        await this._updateRoleAndDepartment({ localDepartment: null, department });\n      } else if (message.ChangeType === 'delete_party') {\n        await this._deleteRoleAndDepartment({ localDepartment: null, department });\n        // build roles\n        await this.ctx.meta.role.build();\n      }\n    }\n\n    async _queueChangeContactMember({ message }) {\n      const member = {};\n      this._adjustFields(member, message, __memberFieldMap_XML);\n      // do\n      if (message.ChangeType === 'create_user') {\n        // get member remotely\n        const res = await this.ctx.meta.wxwork.app.contacts.getUser(member.memberId);\n        if (res.errcode) {\n          throw new Error(res.errmsg);\n        }\n        // create\n        const _member = {};\n        this._adjustFields(_member, res, __memberFieldMap);\n        await this._createUserAndMember({ member: _member });\n      } else if (message.ChangeType === 'update_user') {\n        // check if memberId changed\n        if (member.memberIdNew) {\n          // upate memberId of member\n          await this.ctx.model.query(\n            'update aWxworkUser a set a.memberId=? where a.iid=? and a.memberId=?',\n            [ member.memberIdNew, this.ctx.instance.id, member.memberId ]\n          );\n          // upate profileId of auth\n          await this.ctx.model.query(\n            'update aAuth a set a.profileId=? where a.iid=? and a.profileId=?',\n            [ `wxwork:${member.memberIdNew}`, this.ctx.instance.id, `wxwork:${member.memberId}` ]\n          );\n        }\n        // get member remotely\n        const res = await this.ctx.meta.wxwork.app.contacts.getUser(member.memberIdNew || member.memberId);\n        if (res.errcode) {\n          throw new Error(res.errmsg);\n        }\n        // update\n        const _member = {};\n        this._adjustFields(_member, res, __memberFieldMap);\n        await this._updateUserAndMember({ localMember: null, member: _member });\n      } else if (message.ChangeType === 'delete_user') {\n        await this._deleteUserAndMember({ localMember: null, member });\n      }\n    }\n\n    // queue sync departments\n    async _queueSyncDepartments({ progressId, userOp }) {\n      // prepare context\n      const context = {\n        remoteDepartments: null,\n        progressId,\n        userOp,\n      };\n      try {\n        // progress\n        await this._progressPublish({ context, done: 0, text: `--- ${this.ctx.text('Sync Started')} ---` });\n        // remote departments\n        const res = await this.ctx.meta.dingtalk.app.selfBuilt.department.list({\n          fetch_child: true,\n          id: 1,\n        });\n        // special for departmentId=1\n        const department1 = await this.ctx.meta.dingtalk.app.selfBuilt.department.get(1);\n        res.department.splice(0, 0, department1);\n        context.remoteDepartments = res.department;\n        // progress\n        await this._progressPublish({ context, done: 0, text: `--- ${this.ctx.text('Department Count')}: ${context.remoteDepartments.length} ---` });\n        // local departments\n        context.localDepartments = await this.ctx.model.department.select();\n        context.localDepartmentsMap = {};\n        for (const localDepartment of context.localDepartments) {\n          localDepartment.__status = 0;\n          context.localDepartmentsMap[localDepartment.departmentId] = localDepartment;\n        }\n        // loop create/update\n        for (const remoteDepartment of context.remoteDepartments) {\n          await this._queueSyncDepartment({ context, remoteDepartment });\n        }\n        // delete __status===0\n        for (const departmentId in context.localDepartmentsMap) {\n          const localDepartment = context.localDepartmentsMap[departmentId];\n          if (localDepartment.__status === 0) {\n            await this._deleteRoleAndDepartment({ localDepartment, department: null });\n            // progress\n            await this._progressPublish({ context, done: 0, text: `- ${localDepartment.departmentName}` });\n          }\n        }\n        // build roles\n        await this.ctx.meta.role.build();\n        // progress done\n        await this._progressPublish({ context, done: 1, text: `--- ${this.ctx.text('Sync Completed')} ---` });\n      } catch (err) {\n        // progress error\n        await this._progressPublish({ context, done: -1, text: err.message });\n        // throw err\n        throw err;\n      }\n    }\n\n    // queue sync members\n    async _queueSyncMembers({ progressId, userOp }) {\n      // prepare context\n      const context = {\n        remoteMembers: null,\n        progressId,\n        userOp,\n      };\n      try {\n        // progress\n        await this._progressPublish({ context, done: 0, text: `--- ${this.ctx.text('Sync Started')} ---` });\n        // remote members\n        const departmentRoot = await this.ctx.model.department.get({ departmentParentId: 0 });\n        if (!departmentRoot) return this.ctx.throw(1006);\n        const res = await this.ctx.meta.dingtalk.app.selfBuilt.user.listAll(null, false);\n        context.remoteMembers = res.userlist;\n        // progress\n        await this._progressPublish({ context, done: 0, text: `--- ${this.ctx.text('Member Count')}: ${context.remoteMembers.length} ---` });\n        // local members\n        context.localMembers = await this.ctx.model.member.select();\n        context.localMembersMap = {};\n        for (const localMember of context.localMembers) {\n          localMember.__status = 0;\n          context.localMembersMap[localMember.memberId] = localMember;\n        }\n        // loop create/update\n        for (const remoteMember of context.remoteMembers) {\n          await this._queueSyncMember({ context, remoteMember });\n        }\n        // delete __status===0\n        for (const memberId in context.localMembersMap) {\n          const localMember = context.localMembersMap[memberId];\n          if (localMember.__status === 0) {\n            await this._deleteUserAndMember({ localMember, member: null });\n            // progress\n            await this._progressPublish({ context, done: 0, text: `- ${localMember.name}` });\n          }\n        }\n        // progress done\n        await this._progressPublish({ context, done: 1, text: `--- ${this.ctx.text('Sync Completed')} ---` });\n      } catch (err) {\n        // progress error\n        await this._progressPublish({ context, done: -1, text: err.message });\n        // throw err\n        throw err;\n      }\n    }\n\n    async _progressPublish({ context, done, text }) {\n      const ioMessage = {\n        userIdTo: context.userOp.id,\n        messageFilter: context.progressId,\n        content: { done, text },\n      };\n      await this.ctx.meta.io.publish({\n        path: `/${moduleInfo.url}/progress/${context.progressId}`,\n        message: ioMessage,\n        messageClass: {\n          module: moduleInfo.relativeName,\n          messageClassName: 'progress',\n        },\n        options: {\n          saveMessageAsync: true,\n        },\n      });\n    }\n\n    async _queueSyncDepartment({ context, remoteDepartment }) {\n      // retrieve the department details\n      remoteDepartment = await this.ctx.meta.dingtalk.app.selfBuilt.department.get(remoteDepartment.id);\n      if (remoteDepartment.id === 1) remoteDepartment.parentid = 0;\n      // adjust\n      const department = {};\n      this._adjustFields(department, remoteDepartment, __departmentFieldMap);\n      const departmentId = department.departmentId;\n      // check if local department exists\n      const localDepartment = context.localDepartmentsMap[departmentId];\n      // new department\n      if (!localDepartment) {\n        await this._createRoleAndDepartment({ department });\n        // progress\n        await this._progressPublish({ context, done: 0, text: `+ ${department.departmentName}` });\n        // done\n        return;\n      }\n      // update\n      await this._updateRoleAndDepartment({ localDepartment, department });\n      // progress: not prompt\n      // done\n      localDepartment.__status = 1; // handled\n      return;\n    }\n\n    async _queueSyncMember({ context, remoteMember }) {\n      const member = {};\n      this._adjustFields(member, remoteMember, __memberFieldMap);\n      const memberId = member.memberId;\n      // check if local member exists\n      const localMember = context.localMembersMap[memberId];\n      // new member\n      if (!localMember) {\n        await this._createUserAndMember({ member });\n        // progress\n        await this._progressPublish({ context, done: 0, text: `+ ${member.name}` });\n        // done\n        return;\n      }\n      // update\n      await this._updateUserAndMember({ localMember, member });\n      // progress: not prompt\n      // done\n      localMember.__status = 1; // handled\n      return;\n    }\n\n    async _deleteRoleAndDepartment({ localDepartment, department }) {\n      // localDepartment\n      if (!localDepartment) {\n        localDepartment = await this.ctx.model.department.get({ departmentId: department.departmentId });\n        if (!localDepartment) {\n          this.ctx.throw(1004, department.departmentId);\n        }\n      }\n      // delete role\n      await this.ctx.meta.role.delete({ roleId: localDepartment.roleId, force: true });\n      // delete department\n      await this.ctx.model.department.delete({ id: localDepartment.id });\n    }\n\n    async _deleteUserAndMember({ localMember, member }) {\n      // localMember\n      if (!localMember) {\n        localMember = await this.ctx.model.member.get({ memberId: member.memberId });\n        if (!localMember) {\n          this.ctx.throw(1005, member.memberId);\n        }\n      }\n      const userId = localMember.userId;\n      // delete user: including roles/auth\n      await this.ctx.meta.user.delete({ userId });\n      // delete member\n      await this.ctx.model.member.delete({ id: localMember.id });\n    }\n\n    async _updateRoleAndDepartment({ localDepartment, department }) {\n      // localDepartment\n      if (!localDepartment) {\n        localDepartment = await this.ctx.model.department.get({ departmentId: department.departmentId });\n        if (!localDepartment) {\n          this.ctx.throw(1004, department.departmentId);\n        }\n      }\n      // update role name\n      if (department.departmentName) {\n        await this.ctx.meta.role.save({\n          roleId: localDepartment.roleId,\n          data: { roleName: department.departmentName },\n        });\n      }\n      // update department\n      department.id = localDepartment.id;\n      await this.ctx.model.department.update(department);\n    }\n\n    async _updateUserRoles({ userId, departmentIdsOld, departmentIdsNew }) {\n      const departmentIdsAdd = [];\n      const departmentIdsDelete = [];\n      for (const departmentId of departmentIdsNew) {\n        if (departmentIdsOld.indexOf(departmentId) === -1) {\n          departmentIdsAdd.push(departmentId);\n        }\n      }\n      for (const departmentId of departmentIdsOld) {\n        if (departmentIdsNew.indexOf(departmentId) === -1) {\n          departmentIdsDelete.push(departmentId);\n        }\n      }\n      // add\n      await this._addUserRoles({ userId, departmentIds: departmentIdsAdd });\n      // delete\n      await this._deleteUserRoles({ userId, departmentIds: departmentIdsDelete });\n    }\n\n    async _updateUserAndMember({ localMember, member }) {\n      // localMember\n      if (!localMember) {\n        localMember = await this.ctx.model.member.get({ memberId: member.memberId });\n        if (!localMember) {\n          this.ctx.throw(1005, member.memberId);\n        }\n      }\n      const userId = localMember.userId;\n      // roles\n      if (member.department !== undefined && member.department !== localMember.department) {\n        await this._updateUserRoles({\n          userId,\n          departmentIdsOld: (localMember.department || '').split(','),\n          departmentIdsNew: (member.department || '').split(','),\n        });\n      }\n      // active\n      if (member.active !== undefined && member.active !== localMember.active) {\n        await this.ctx.meta.user.disable({ userId, disabled: !member.active });\n      }\n      // update member\n      member.id = localMember.id;\n      await this.ctx.model.member.update(member);\n    }\n\n    async _createRoleAndDepartment({ department }) {\n      // get parent role\n      const roleParent = await this._getRoleOfDepartment({ departmentId: department.departmentParentId });\n      if (!roleParent) {\n        this.ctx.throw(1003, department.departmentParentId);\n      }\n      // create current role\n      const roleIdCurrent = await this.ctx.meta.role.add({\n        roleName: department.departmentName,\n        catalog: 0, // update by sub role\n        sorting: department.departmentOrder,\n        roleIdParent: roleParent.id,\n      });\n        // force change parent role to catalog=1\n      await this.ctx.meta.role.save({\n        roleId: roleParent.id,\n        data: { catalog: 1 },\n      });\n      // creat department\n      department.roleId = roleIdCurrent;\n      const res = await this.ctx.model.department.insert(department);\n      return res.insertId;\n    }\n\n    // [1,2]\n    async _addUserRoles({ userId, departmentIds }) {\n      for (const departmentId of departmentIds) {\n        // get role of department\n        const roleCurrent = await this._getRoleOfDepartment({ departmentId });\n        if (!roleCurrent) {\n          this.ctx.throw(1003, departmentId);\n        }\n        // add user role\n        await this.ctx.meta.role.addUserRole({ userId, roleId: roleCurrent.id });\n      }\n    }\n\n    async _deleteUserRoles({ userId, departmentIds }) {\n      for (const departmentId of departmentIds) {\n        // get role of department\n        const roleCurrent = await this._getRoleOfDepartment({ departmentId });\n        if (!roleCurrent) {\n          this.ctx.throw(1003, departmentId);\n        }\n        // add user role\n        await this.ctx.meta.role.deleteUserRole({ userId, roleId: roleCurrent.id });\n      }\n    }\n\n    async _createUserAndMember({ member }) {\n      // 1. create user&auth\n      // verify auth user\n      const dingtalkHelper = new (DingtalkHelperFn(this.ctx))();\n      const verifyUser = await dingtalkHelper.verifyAuthUser({ scene: 'dingtalk', member, needLogin: false });\n      const userId = verifyUser.agent.id;\n\n      // 2. add user to role\n      if (member.department) {\n        await this._addUserRoles({ userId, departmentIds: member.department.split(',') });\n        // delete role:activated (need not)\n      }\n\n      // 3. active\n      if (!member.active) {\n        await this.ctx.meta.user.disable({ userId, disabled: true });\n      }\n\n      // 4. create member\n      member.userId = userId;\n      const res = await this.ctx.model.member.insert(member);\n      return res.insertId;\n    }\n\n    // not create new role here\n    async _getRoleOfDepartment({ departmentId }) {\n      // role top\n      if (departmentId === 0) {\n        return await this._getRoleTop();\n      }\n      // department\n      const department = await this.ctx.model.department.get({ departmentId });\n      if (!department) return null;\n      return await this.ctx.meta.role.get({ id: department.roleId });\n    }\n\n    // get role top\n    async _getRoleTop() {\n      const roleContainer = await this.ctx.meta.role.get({ roleName: this.ctx.config.sync.department.roleContainer });\n      const roleTop = await this.ctx.meta.role.get({ roleName: this.ctx.config.sync.department.roleTop, roleIdParent: roleContainer.id });\n      if (roleTop) return roleTop;\n      // create role\n      const data = {\n        roleName: this.ctx.config.sync.department.roleTop,\n        catalog: 1,\n        sorting: 0,\n        roleIdParent: roleContainer.id,\n      };\n      data.id = await this.ctx.meta.role.add(data);\n      return data;\n    }\n\n    _adjustFields(itemDest, itemSrc, fieldMap) {\n      for (const index in fieldMap[1]) {\n        const field = fieldMap[1][index];\n        if (itemSrc[field] !== undefined) {\n          const fieldDest = fieldMap[0][index];\n          itemDest[fieldDest] = this._adjustFieldType(itemSrc[field], fieldMap[2][index]);\n        }\n      }\n    }\n    _adjustFieldType(value, type) {\n      if (type === 'number') return Number(value);\n      else if (type === 'bool') return Boolean(value);\n      else if (type === 'string') return String(value);\n      else if (type === 'array') return value.join(',');\n      else if (type === 'json') return JSON.stringify(value);\n      else if (type === 'timestamp') return new Date(value);\n      return value;\n    }\n\n  }\n\n  return Contacts;\n};\n","const require3 = require('require3');\nconst extend = require3('extend2');\n\nmodule.exports = app => {\n\n  class Event extends app.Service {\n\n    async loginInfo({ /* event,*/ data }) {\n      const info = data.info;\n      const provider = info.user && info.user.provider;\n      if (provider && provider.module === 'a-wxwork') {\n        info.config = extend(true, info.config, {\n          modules: {\n            'a-base': {\n              account: {\n                needActivation: false,\n              },\n            },\n          },\n        });\n      }\n    }\n\n  }\n\n  return Event;\n};\n","module.exports = app => {\n\n  class JSSDK extends app.Service {\n\n    async jsconfig({ url }) {\n      // config\n      const config = this.ctx.config.account.wxwork;\n      const configAppSelfBuilt = config.apps.selfBuilt;\n      // params\n      const params = {\n        debug: configAppSelfBuilt.jssdk.debug,\n        jsApiList: configAppSelfBuilt.jssdk.jsApiList,\n        url,\n      };\n      return await this.ctx.meta.wxwork.app.selfBuilt.getJsConfig(params);\n    }\n\n    async jsconfigAgent({ url }) {\n      // config\n      const config = this.ctx.config.account.wxwork;\n      const configAppSelfBuilt = config.apps.selfBuilt;\n      // params\n      const params = {\n        agentid: configAppSelfBuilt.agentid,\n        jsApiList: configAppSelfBuilt.jssdkAgent.jsApiList,\n        url,\n      };\n      return await this.ctx.meta.wxwork.app.selfBuilt.getJsConfigAgent(params);\n    }\n\n  }\n\n  return JSSDK;\n};\n","const DingtalkHelperFn = require('../common/dingtalkHelper.js');\n\nmodule.exports = app => {\n\n  class AuthMini extends app.Service {\n\n    async login({ scene, code }) {\n      if (!code) return this.ctx.throw(403);\n      const res = await this.ctx.meta.wxwork.app.mini[scene].code2Session(code);\n      // const res = { errcode: 0, userid: 'YangJian1', session_key: 'kJtdi6RF+Dv67QkbLlPGjw==' };\n      if (res.errcode) throw new Error(res.errmsg);\n      const session_key = res.session_key;\n      const memberId = res.userid;\n      // verify\n      const wxworkHelper = new (WxworkHelperFn(this.ctx))();\n      await wxworkHelper.verifyAuthUser({ scene: `wxworkmini${scene}`, memberId });\n      // save session_key, because ctx.user maybe changed\n      await this.ctx.meta.wxwork.mini[scene].saveSessionKey(session_key);\n      // echo\n      return await this.ctx.meta.auth.echo();\n    }\n\n  }\n\n  return AuthMini;\n};\n","const department = require('./model/department.js');\nconst member = require('./model/member.js');\n\nmodule.exports = app => {\n  const models = {\n    department,\n    member,\n  };\n  return models;\n};\n","module.exports = app => {\n  class Department extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aDingtalkDepartment', options: { disableDeleted: true } });\n    }\n  }\n  return Department;\n};\n","module.exports = app => {\n  class Member extends app.meta.Model {\n    constructor(ctx) {\n      super(ctx, { table: 'aDingtalkMember', options: { disableDeleted: false } });\n    }\n  }\n  return Member;\n};\n","const authFn = require('./passport/auth.js');\n\nmodule.exports = app => {\n  // const schemas = require('./config/validation/schemas.js')(app);\n  // socketio\n  const socketioMessageProgress = require('./config/socketio/messageProgress.js')(app);\n  const socketioChannelApp = require('./config/socketio/channelApp.js')(app);\n  const meta = {\n    base: {\n      atoms: {\n      },\n      functions: {\n        contacts: {\n          title: 'Contacts Management',\n          actionPath: 'contacts/management',\n          sorting: 1,\n          menu: 0,\n        },\n      },\n    },\n    validation: {\n      validators: {\n      },\n      keywords: {},\n      schemas: {\n      },\n    },\n    settings: {\n      instance: {\n        actionPath: 'settings/list',\n      },\n    },\n    event: {\n      declarations: {\n        wxworkMessage: 'Wechat Work Message',\n      },\n      implementations: {\n        'a-base:loginInfo': 'event/loginInfo',\n      },\n    },\n    index: {\n      indexes: {\n        aDingtalkDepartment: 'createdAt,updatedAt,roleId,departmentId,departmentParentId',\n        aDingtalkMember: 'createdAt,updatedAt,userId,memberId',\n      },\n    },\n    socketio: {\n      messages: {\n        progress: socketioMessageProgress,\n      },\n      channels: {\n        app: socketioChannelApp,\n      },\n    },\n    auth: authFn,\n  };\n  return meta;\n};\n","const strategy = require('./strategy-dingtalk.js');\nconst DingtalkHelperFn = require('../common/dingtalkHelper.js');\nconst authProviderScenes = require('../common/authProviderScenes.js');\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n\n  function _createProviderDingTalk() {\n    return {\n      meta: {\n        title: 'DingTalk',\n        mode: 'direct',\n        disableAssociate: true,\n        component: 'buttondingtalk',\n      },\n      config: {\n      },\n      handler: null,\n    };\n  }\n\n  function _createProviderDingTalkWeb() {\n    return {\n      meta: {\n        title: 'DingTalk Web',\n        mode: 'redirect',\n        disableAssociate: true,\n        component: 'buttondingtalkweb',\n      },\n      config: {\n        client: 'dingtalkweb',\n        scope: 'snsapi_login',\n      },\n      configFunctions: {\n        getConfig(ctx) {\n          const config = ctx.config.module(moduleInfo.relativeName).account.dingtalk.webs.default;\n          return { appkey: config.appid, appsecret: config.appsecret };\n        },\n      },\n      handler: app => {\n        return {\n          strategy,\n          callback: (req, loginTmpCode, done) => {\n            // ctx/state\n            const ctx = req.ctx;\n            const state = ctx.request.query.state || 'login';\n            // code/memberId\n            const dingtalkHelper = new (DingtalkHelperFn(ctx))();\n            const api = dingtalkHelper.createDingtalkApi();\n            api.web.default.client.getuserinfo_bycode(loginTmpCode).then(res => {\n              const unionid = res.user_info.unionid;\n              api.app.selfBuilt.user.getUseridByUnionid(unionid).then(res => {\n                if (res.contactType === 1) throw new Error('not support extcontact');\n                const memberId = res.userid;\n                dingtalkHelper.verifyAuthUser({\n                  scene: 'dingtalkweb',\n                  memberId,\n                  state,\n                  cbVerify: (profileUser, cb) => {\n                    app.passport.doVerify(req, profileUser, cb);\n                  },\n                }).then(verifyUser => { done(null, verifyUser); }).catch(done);\n              }).catch(done);\n            }).catch(done);\n          },\n        };\n      },\n    };\n  }\n\n  function _createProviderDingTalkAdmin() {\n    return {\n      meta: {\n        title: 'DingTalk Admin',\n        mode: 'redirect',\n        disableAssociate: true,\n      },\n      config: {\n      },\n      configFunctions: {\n        getConfig(ctx) {\n          const config = ctx.config.module(moduleInfo.relativeName).account.dingtalk;\n          return { appkey: config.corpid, appsecret: config.ssosecret };\n        },\n      },\n      handler: app => {\n        return {\n          strategy,\n          callback: (req, code, done) => {\n            // ctx/state\n            const ctx = req.ctx;\n            const state = ctx.request.query.state || 'login';\n            // code/memberId\n            const dingtalkHelper = new (DingtalkHelperFn(ctx))();\n            const api = dingtalkHelper.createDingtalkApi();\n            api.admin.client.getSSOUserInfo(null, code).then(res => {\n              const memberId = res.user_info.userid;\n              dingtalkHelper.verifyAuthUser({\n                scene: 'dingtalkadmin',\n                memberId,\n                state,\n                cbVerify: (profileUser, cb) => {\n                  app.passport.doVerify(req, profileUser, cb);\n                },\n              }).then(verifyUser => { done(null, verifyUser); }).catch(done);\n            }).catch(done);\n          },\n        };\n      },\n    };\n  }\n\n  function _createProviderMini(sceneInfo) {\n    return {\n      meta: {\n        title: sceneInfo.title,\n        mode: 'direct',\n        disableAssociate: true,\n      },\n      config: {\n      },\n      handler: null,\n    };\n  }\n\n  const metaAuth = {\n    providers: {\n    },\n  };\n\n  // dingtalk\n  metaAuth.providers.dingtalk = _createProviderDingTalk();\n  // dingtalkweb\n  metaAuth.providers.dingtalkweb = _createProviderDingTalkWeb();\n  // dingtalkadmin\n  metaAuth.providers.dingtalkadmin = _createProviderDingTalkAdmin();\n\n  // minis\n  const moduleConfig = app.meta.configs[moduleInfo.relativeName];\n  const minis = moduleConfig.account.dingtalk.minis;\n  for (const sceneShort in minis) {\n    const scene = `dingtalkmini${sceneShort}`;\n    const sceneInfo = authProviderScenes.getScene(scene);\n    metaAuth.providers[sceneInfo.authProvider] = _createProviderMini(sceneInfo);\n  }\n\n  // ok\n  return metaAuth;\n};\n","const require3 = require('require3');\nconst util = require3('util');\nconst passport = require3('passport-strategy');\nconst OAuth = require('./oauth.js');\n\nconst __OAUTH = Symbol('DINGTALK#__OAUTH');\n\nfunction DingTalkStrategy(options, verify) {\n  options = options || {};\n\n  if (!verify) {\n    throw new TypeError('DingTalkStrategy required a verify callback');\n  }\n\n  if (typeof verify !== 'function') {\n    throw new TypeError('_verify must be function');\n  }\n\n  passport.Strategy.call(this, options, verify);\n\n  this.name = options.name || 'dingtalk';\n  this._client = options.client || 'dingtalk';\n  this._verify = verify;\n  this._callbackURL = options.callbackURL;\n  this._lang = options.lang || 'en';\n  this._state = options.state;\n  this._scope = options.scope || 'snsapi_login';\n  this._passReqToCallback = options.passReqToCallback;\n\n}\n\nutil.inherits(DingTalkStrategy, passport.Strategy);\n\nDingTalkStrategy.prototype.getOAuth = function(options) {\n  if (this[__OAUTH] === undefined) {\n    let appkey = options.appkey;\n    if (!appkey) {\n      const _config = options.getConfig();\n      appkey = _config.appkey;\n    }\n    this[__OAUTH] = new OAuth(appkey);\n  }\n  return this[__OAUTH];\n};\n\nDingTalkStrategy.prototype.authenticate = function(req, options) {\n\n  if (!req._passport) {\n    return this.error(new Error('passport.initialize() middleware not in use'));\n  }\n\n  const self = this;\n\n  options = options || {};\n\n  // oauth\n  const _oauth = this.getOAuth(options);\n\n  // 校验完成信息\n  function verified(err, user, info) {\n    if (err) {\n      return self.error(err);\n    }\n    if (!user) {\n      return self.fail(info);\n    }\n    self.success(user, info);\n  }\n\n  // 获取code授权成功\n  if (req.url.indexOf('/callback') > -1) {\n\n    // 获取code,并校验相关参数的合法性\n    // No code only state --> User has rejected send details. (Fail authentication request).\n    if (req.query && !req.query.code) {\n      return self.fail(401);\n    }\n\n    // Documentation states that if user rejects userinfo only state will be sent without code\n    // In reality code equals \"authdeny\". Handle this case like the case above. (Fail authentication request).\n    if (req.query && req.query.code === 'authdeny') {\n      return self.fail(401);\n    }\n\n    const code = req.query.code;\n\n    try {\n      if (self._passReqToCallback) {\n        self._verify(req, code, verified);\n      } else {\n        self._verify(code, verified);\n      }\n    } catch (ex) {\n      return self.error(ex);\n    }\n\n  } else {\n    const state = options.state || self._state;\n    const callbackURL = options.callbackURL || self._callbackURL;\n    const scope = options.scope || self._scope;\n\n    // only support dingtalkweb\n    const methodName = (this._client === 'dingtalkweb') ? 'getAuthorizeURLForWebsite' : '';\n    const location = _oauth[methodName](callbackURL, state, scope);\n\n    self.redirect(location, 302);\n  }\n};\n\nmodule.exports = DingTalkStrategy;\n","const require3 = require('require3');\nconst querystring = require3('querystring');\n\nconst OAuth = function(appkey) {\n  this.appkey = appkey;\n};\n\nOAuth.prototype.getAuthorizeURLForWebsite = function(redirect, state) {\n  const url = 'https://oapi.dingtalk.com/connect/qrconnect';\n  const info = {\n    appid: this.appkey,\n    response_type: 'code',\n    scope: 'snsapi_login',\n    state: state || '',\n    redirect_uri: redirect,\n  };\n\n  return url + '?' + querystring.stringify(info);\n};\n\nmodule.exports = OAuth;\n","module.exports = app => {\n  const progress = {\n    info: {\n      title: 'Progress',\n      persistence: true,\n    },\n    callbacks: {\n    },\n  };\n  return progress;\n};\n","const DingtalkHelperFn = require('../../common/dingtalkHelper.js');\n\nmodule.exports = app => {\n  const moduleInfo = app.meta.mockUtil.parseInfoFromPackage(__dirname);\n  async function onPush({ ctx, content }) {\n    // userIds / roleIds\n    const userIds = content.userIds;\n    const roleIds = content.roleIds;\n    // message\n    const message = {\n      ... content.data,\n    };\n    // agentid\n    const config = ctx.config.module(moduleInfo.relativeName).account.wxwork;\n    message.agentid = config.apps.selfBuilt.agentid;\n    // userIds\n    if (userIds && userIds.length > 0) {\n      const modelMember = ctx.model.module(moduleInfo.relativeName).member;\n      const list = await modelMember.select({\n        where: { userId: userIds },\n        columns: [ 'memberId' ],\n      });\n      message.touser = list.map(item => item.memberId).join('|');\n    }\n    // roleIds\n    if (roleIds && roleIds.length > 0) {\n      const modelDepartment = ctx.model.module(moduleInfo.relativeName).department;\n      const list = await modelDepartment.select({\n        where: { roleId: roleIds },\n        columns: [ 'departmentId' ],\n      });\n      message.toparty = list.map(item => item.departmentId).join('|');\n    }\n    // send\n    const wxworkHelper = new (WxworkHelperFn(ctx))();\n    const api = wxworkHelper.createWxworkApi();\n    await api.app.selfBuilt.sendMessage(message);\n    // done\n    return true;\n  }\n\n  const ChannelApp = {\n    info: {\n      title: 'App Message',\n    },\n    callbacks: {\n      onPush,\n    },\n  };\n  return ChannelApp;\n};\n"],"sourceRoot":""}